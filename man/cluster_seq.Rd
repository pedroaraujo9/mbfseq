% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_seq.R
\name{cluster_seq}
\alias{cluster_seq}
\title{Clustering sequence with a Bayesian functional mixture of categorical distributions}
\usage{
cluster_seq(
  M,
  z,
  id,
  time,
  w = NULL,
  lambda = NULL,
  n_basis = 10,
  fixed_sd = 10,
  iters = 1000,
  thin = 1,
  burn_in = iters/2,
  epsilon = 1,
  bounds = c(0.01, 5),
  max_iter_start = 30,
  n_start = 30,
  n_cores = 1,
  n_cores_init = 1,
  intercept = FALSE,
  verbose = FALSE,
  seed = NULL
)
}
\arguments{
\item{M}{Integer vector. The number(s) of clusters to fit for the secondary clustering w. Model will be run for each value of M.}

\item{z}{Integer vector. Primary cluster assignments for each subject or observation.}

\item{id}{Vector of subject or observation identifiers.}

\item{time}{Numeric vector indicating the time for each observation.}

\item{w}{(Optional) Vector of initial cluster assignments for the secondary clustering. If NULL, will be estimated.}

\item{lambda}{(Optional) Regularization or penalty hyperparameter. If NULL, will be tuned internally via grid search for each M.}

\item{n_basis}{Integer. Number of basis functions for time expansion (default: 10).}

\item{fixed_sd}{Numeric. Standard deviation for proposal or prior (default: 10).}

\item{iters}{Integer. Number of Markov chain or EM iterations for each fit (default: 1000).}

\item{thin}{Integer. Thinning of chain (default: 1; keep all samples).}

\item{burn_in}{Integer. Number of iterations to discard as burn-in (default: iters/2).}

\item{epsilon}{Numeric. Small value used as prior/jitter (default: 1).}

\item{bounds}{Numeric vector of length 2. Min and max lambda explored in grid search (default: c(0.01, 5)).}

\item{max_iter_start}{Integer. Number of steps per short chain for robust initialization (default: 30).}

\item{n_start}{Integer. Number of initialization chains (default: 30).}

\item{n_cores}{Integer. Number of CPU cores to use for parallelization across M (default: 1).}

\item{n_cores_init}{Integer. Number of CPU cores used for parallelization during initialization step (default: 1).}

\item{intercept}{Logical. Whether to include an intercept in the model (default: FALSE).}

\item{verbose}{Logical. If TRUE, prints progress messages (default: FALSE).}

\item{seed}{(Optional) Random seed for reproducibility.}
}
\value{
A list with:
\describe{
\item{fits}{List of fitted model outputs from clustseq_single_run, one for each value of M.}
\item{metrics}{Sequence clustering evaluation metrics computed from all fits (see comp_seq_metrics).}
\item{opt_lambda}{Numeric vector of optimal lambda values selected for each M.}
\item{run_time}{Total run time for the procedure (as a difftime object).}
}
}
\description{
Run the full cluster sequence modeling pipeline for varying numbers of clusters (M), including model data preparation, (optional) lambda calibration, robust initialization, model fitting, and metrics/summary extraction. Can be parallelized across cluster values.
}
\details{
For each value of M:
\itemize{
\item Creates model data structure via create_model_data
\item If lambda is NULL, chooses an optimal lambda via calibrate_lambda (grid search)
\item Finds robust initialization via clustseq_find_init (using multiple short chains)
\item Fits full model via clustseq_single_run
}
Multi-core execution (across values of M and/or for initialization) is implemented via the future and future.apply packages. Progress is optionally displayed via the progressr package.
}
\examples{
\dontrun{
  time <- rep(1:3, 10)
  id <- rep(1:10, each = 3)
  z <- rep(1:2, each = 15)
  set.seed(123)
  res <- cluster_seq(M = 2:3, z = z, id = id, time = time, n_cores = 2, n_cores_init = 2,
                     verbose = TRUE, n_start = 3, max_iter_start = 3, iters = 10)
  str(res)
}
}
\seealso{
create_model_data, calibrate_lambda, clustseq_find_init, clustseq_single_run, comp_seq_metrics
}
