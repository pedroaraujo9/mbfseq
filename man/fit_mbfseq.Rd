% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mbfseq_fit.R
\name{fit_mbfseq}
\alias{fit_mbfseq}
\title{Fit Sequential Model}
\usage{
fit_mbfseq(
  G = NULL,
  M = NULL,
  z = NULL,
  w = NULL,
  x = NULL,
  id,
  time,
  iters = 1000,
  burn_in = iters/2,
  thin = 5,
  lambda = NULL,
  n_basis = 10,
  init_list = NULL,
  n_cores = 1,
  config = list(bounds = c(0.01, 10), lambda_start = 1, n_points = 20, n_start = 30,
    n_start_iters = 20, n_start_cores = 1, epsilon_w = 1, beta_sd = sqrt(10), mu_sd =
    sqrt(10), sigma_a = 1, sigma_b = 1),
  verbose = TRUE,
  seed = NULL
)
}
\arguments{
\item{G}{Numeric vector of possible values for \code{G}.}

\item{M}{Numeric vector of possible values for \code{M}.}

\item{z}{Optional sequence values to be clustered.}

\item{w}{Optional sequence clusters.}

\item{x}{Optional covariate matrix to find z.}

\item{id}{Vector of subject or group identifiers.}

\item{time}{Vector of time points corresponding to the observations.}

\item{iters}{Integer. Total number of MCMC iterations. Default is 1000.}

\item{burn_in}{Integer. Number of burn-in iterations. Default is \code{iters/2}.}

\item{thin}{Integer. Thinning interval for MCMC sampling. Default is 5.}

\item{lambda}{Optional numeric value for the regularization parameter. If \code{NULL},
the optimal lambda is estimated via \code{\link{calibrate_lambda}}.}

\item{n_basis}{Integer. Number of spline basis functions (includes intercept). Default is 10.}

\item{init_list}{Optional list of initial values for model parameters.}

\item{n_cores}{Integer. Number of CPU cores to use for parallel processing. Default is 1.}

\item{config}{List of additional configuration parameters:
\describe{
\item{\code{n_start}}{Number of random initializations.}
\item{\code{n_start_iter}}{Number of iterations for initialization search.}
\item{\code{n_start_cores}}{Number of cores for initialization search.}
\item{\code{epsilon_w}, \code{beta_sd}, \code{mu_sd}, \code{sigma_a}, \code{sigma_b}}{Priors and scaling constants.}
\item{\code{bounds}}{Range for lambda search.}
\item{\code{n_grid}}{Number of grid points for lambda search.}
}}

\item{verbose}{Logical. If \code{TRUE}, prints progress messages. Default is TRUE.}

\item{seed}{Optional integer seed for reproducibility. If \code{NULL}, a random seed is generated.}
}
\value{
A list containing:
\describe{
\item{\code{fit}}{List of fitted model objects.}
\item{\code{init}}{List of initialization results.}
\item{\code{lambda_opt}}{List of optimal lambda search results.}
\item{\code{best_lambda}}{Numeric vector of best lambda values.}
\item{\code{run_time}}{Total runtime as a \code{difftime} object.}
\item{\code{seed}}{Random seed used.}
\item{\code{metrics}}{Formatted model performance metrics.}
\item{\code{model_data}}{Minimal model data object.}
}
}
\description{
Fits a multi-basis function sequential model for given combinations of
\code{G} and \code{M}, performing lambda calibration, initialization search,
and final model fitting. Supports parallel processing for model combinations.
}
\details{
This function iterates over all combinations of \code{G} and \code{M} values,
fits the corresponding model using \code{\link{single_run}}, and computes performance metrics
with \code{\link{comp_metrics}}.

If \code{lambda} is \code{NULL}, \code{\link{calibrate_lambda}} is used to find the optimal value.
Initialization values are obtained using \code{\link{find_init}}.
}
\examples{
\dontrun{
result <- fit_mbfseq(G = c(2, 3), M = c(4, 5),
                     id = rep(1:10, each = 5),
                     time = rep(1:5, times = 10),
                     iters = 500, n_cores = 2)
}

}
