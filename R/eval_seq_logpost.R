#' Evaluate Sequence Model Log-Posterior
#'
#' Computes the log-posterior density for a sequence model combining categorical likelihood
#' and Gaussian priors with different penalties for parameters.
#'
#' @param z Numeric vector with sequences.
#' @param alpha Numeric matrix of category-specific coefficients.
#' @param w Numeric vector with id clusters.
#' @param lambda Numeric value controlling the strength of penalization.
#' @param fixed_sd Numeric value specifying the standard deviation for non-penalized parameters.
#' @param model_data List containing model structure and data components generated by `gen_model_data`.
#'
#' @return The computed log-posterior density value.
#'
#' @details
#' This function computes:
#' \enumerate{
#'   \item The log-likelihood from categorical probabilities predicted by \code{predict_cat}
#'   \item Penalized prior terms for coefficients specified in \code{model_data$notpen_index}
#'   \item Non-penalized prior terms for remaining coefficients
#' }
#'
#' The penalization uses different standard deviations:
#' \itemize{
#'   \item \code{sqrt(lambda/diag(model_data$nD)[-1])} for penalized parameters
#'   \item \code{fixed_sd} for non-penalized parameters
#' }
#'
#' @importFrom stats dnorm
#' @importFrom Rcpp sourceCpp
#' @importFrom methods is
#'
#' @examples
#' \dontrun{
#' # Example usage (not run)
#' data <- list(
#'   n_basis = 4,
#'   G = 3,
#'   M = 2,
#'   notpen_index = 1:2,
#'   id_time_df = data.frame(time_seq = runif(100), id = rep(1:10, each=10),
#'   nD = diag(4)
#' )
#'
#' result <- eval_seq_logpost(
#'   z = rnorm(100),
#'   alpha = matrix(rnorm(6), nrow=3, ncol=2),
#'   w = rnorm(10),
#'   lambda = 1.0,
#'   fixed_sd = 10,
#'   model_data = data
#' )
#' }
#'
#' @seealso \code{\link{predict_cat}} for the prediction function used in likelihood computation.
eval_seq_logpost = function(z,
                            alpha,
                            w,
                            lambda,
                            fixed_sd,
                            model_data) {

  n_basis = model_data$n_basis
  G = model_data$G
  M = model_data$M
  notpen_index = model_data$notpen_index
  time = model_data$id_time_df$time_seq
  id = model_data$id_time_df$id

  p = predict_cat(
    alpha = alpha,
    z = z,
    w_vec = w[id],
    time_seq = time,
    model_data = model_data,
    intercept = FALSE,
    type = "category probability"
  )

  log_like = sum(log(p))

  alpha_var = matrix(
    lambda/diag(model_data$nD)[-1],
    nrow = M * (n_basis - 1),
    ncol = G - 1
  )

  penal_alpha  = alpha[-notpen_index, -G]
  npenal_alpha = alpha[notpen_index, -G]

  penal = sum(dnorm(penal_alpha, mean = 0, sd = sqrt(alpha_var), log = T))
  npenal = sum(dnorm(npenal_alpha, mean = 0, sd = fixed_sd, log = T))

  return(log_like + penal + npenal)

}



