#' Compute Log Posterior for Cluster Sequence Model
#'
#' Internal: Compute the log posterior (log-likelihood plus log-prior penalties) for a given set of regression parameters, cluster assignments, and penalty hyperparameters in the cluster sequence model. Used internally during MCMC sampling to evaluate model fit and penalization at each step.
#'
#' @param alpha Matrix. Regression/basis coefficients for all clusters (dimension: (n_basis x M) by G).
#' @param w Integer vector. Current secondary clustering assignments for all subjects/observations.
#' @param lambda Numeric matrix. Regularization hyperparameters for penalized coefficients (typically dimension: M by (G-1)).
#' @param model_data A model_data object generated by create_model_data, containing basis, cluster/group, and penalty structure.
#' @param fixed_sd Numeric. The standard deviation for unpenalized parameters (default: typically 10 in workflow).
#'
#' @return A numeric scalar. The total log posterior value: sum of the log-likelihood and all log prior densities for penalized and non-penalized coefficients.
#'
#' @details
#' Computes the log-likelihood as the sum of log-probabilities for observed categories under the current parameterization. Applies penalty terms to the coefficients: coefficients in the penalized set use a variance that depends on lambda and the penalty matrix, while non-penalized coefficients use a fixed variance (fixed_sd). All log-density penalties are computed with the normal distribution (stats::dnorm). Uses predicted probabilities from the helper predict_cat (type = "category probability") for likelihood calculation. Intended for internal use.
#'
#' @importFrom stats dnorm
#' @keywords internal
comp_logpost = function(alpha,
                        w,
                        lambda,
                        model_data,
                        z = NULL,
                        fixed_sd) {

  n_basis = model_data$n_basis
  G = model_data$G
  M = model_data$M
  notpen_index = model_data$notpen_index
  time = model_data$id_time_df$time_seq
  id = model_data$id_time_df$id

  if(is.null(z)) z = model_data$z

  p = predict_cat(
    alpha = alpha,
    z = z,
    w_vec = w[id],
    time_seq = time,
    model_data = model_data,
    intercept = FALSE,
    type = "category probability"
  )

  log_like = sum(log(p))

  alpha_var = matrix(
    lambda[1, 1]/(model_data$nD %>% diag() %>% .[-1]),
    nrow = M * (n_basis - 1),
    ncol = G - 1
  )

  penal_alpha  = alpha[-notpen_index, -G]
  npenal_alpha = alpha[notpen_index, -G]

  penal = sum(dnorm(penal_alpha, mean = 0, sd = sqrt(alpha_var), log = T))
  npenal = sum(dnorm(npenal_alpha, mean = 0, sd = fixed_sd, log = T))

  return(log_like + penal + npenal)

}



