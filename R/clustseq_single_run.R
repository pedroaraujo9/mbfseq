#' Single Run of Cluster Sequence Model
#'
#' Perform a single MCMC run of the cluster sequence model given input model data and (optionally) an initial clustering assignment (w). Iteratively samples or estimates model parameters and clusterings according to posterior (or other) distributions.
#'
#' @param model_data A model_data object generated by create_model_data, containing all required clustering, sequence, and basis information.
#' @param w (Optional) Initial cluster assignment vector for the secondary clustering. If NULL, will be sampled.
#' @param iters Integer. Number of iterations for the sampler (default: 1000).
#' @param thin Integer. Thinning parameter for the Markov chain (default: 1, keep all samples).
#' @param burn_in Integer. Number of iterations to discard as burn-in (default: iters/2).
#' @param lambda (Optional) Regularization or penalty hyperparameter(s).
#' @param n_basis Integer. Number of basis functions (default: 10).
#' @param fixed_sd Numeric. Fixed standard deviation for proposal or prior (default: 10).
#' @param epsilon Numeric. Small value used as a prior or jitter (default: 1).
#' @param intercept Logical. Whether to fit an intercept in the model (default: FALSE).
#' @param init_list (Optional) List of initial values for parameters.
#' @param verbose Logical. Whether to print progress to the console (default: FALSE).
#' @param seed (Optional) Random seed for reproducibility.
#'
#' @return An object of class "seqclust" containing:
#'   \describe{
#'     \item{w_class}{Most probable cluster allocations for each subject/observation (as inferred by comp_class).}
#'     \item{sample_list}{All sampled/estimated parameters, clusterings, and diagnostics.}
#'     \item{model_data}{The original model_data input.}
#'     \item{fixed_sd, lambda, args}{Model run settings and parameters.}
#'   }
#'
#' @details
#' At each iteration, model parameters (e.g. alpha) and cluster assignments (w) are updated according to the model logic. Interactions with external clustering vectors, proposal updates, and cluster probability computations are managed internally. The progress bar prints every 10% of iterations if verbose=TRUE. This function is intended for internal or parallel use and is not exported to end users.
#'
#' @importFrom utils flush.console
#' @examples
#' \dontrun{
#'   # Setup model data using two cluster assignments
#'   time <- rep(1:3, 10)
#'   id <- rep(1:10, each = 3)
#'   z <- rep(1:2, each = 15)
#'   w <- rep(1:2, length.out=30)
#'   x <- matrix(rnorm(30), ncol = 1)
#'   model_data <- create_model_data(time = time, id = id, x = x, z = z, w = w)
#'   # Run the clustering sequence model
#'   fit <- clustseq_single_run(model_data, iters = 200, verbose = TRUE)
#'   str(fit)
#' }
clustseq_single_run = function(model_data,
                               w = NULL,
                               iters = 1000,
                               thin = 1,
                               burn_in = iters/2,
                               lambda = NULL,
                               n_basis = 10,
                               fixed_sd = 10,
                               epsilon = 1,
                               intercept = FALSE,
                               init_list = NULL,
                               verbose = FALSE,
                               seed = NULL) {

  args = list(
    w = w,
    iters = iters,
    thin = thin,
    burn_in = burn_in,
    lambda = lambda,
    n_basis = n_basis,
    fixed_sd = fixed_sd,
    epsilon = epsilon,
    intercept = intercept,
    init_list = init_list,
    verbose = verbose,
    seed = seed
  )


  if(!is.null(seed)) set.seed(seed)

  M = model_data$M

  sample_list = create_sample_list(
    iters = iters,
    model_data = model_data,
    lambda = lambda,
    init_list = init_list,
    epsilon = epsilon
  )

  print_h = floor(iters/10)

  for(i in 2:iters) {

    if(verbose) {
      if (i %% print_h == 0) {
        cat(sprintf("M = %d - Iteration %d / %d\n", M, i, iters))
        utils::flush.console()
      }
    }

    sample_list$alpha[i,,] = update_alpha(
      alpha = sample_list$alpha[i-1,,],
      lambda = sample_list$lambda[i-1,,],
      z = model_data$z,
      w = sample_list$w[i-1, ],
      model_data = model_data,
      fixed_sd = fixed_sd,
      intercept = intercept
    )

    sample_list$prob[i,,] = comp_prob(
      alpha = sample_list$alpha[i,,],
      model_data = model_data
    )

    if(is.null(w)) {

      if(M > 1) {
        sample_list$pw[i, ] = update_pw(
          w = sample_list$w[i-1,],
          epsilon = epsilon,
          model_data = model_data
        )
      }else{
        sample_list$pw[i, ] = 1
      }

      new_w = update_w(
        alpha = sample_list$alpha[i,,],
        pw = sample_list$pw[i, ],
        z = model_data$z,
        model_data = model_data
      )

      sample_list$w[i, ] = new_w$w
      sample_list$id_marg_logp[i,] = new_w$marg_log_like
      sample_list$w_post_prob[i,,] = new_w$w_post_prob
    }

    sample_list$w_logpost[i] = comp_logpost(
      alpha = sample_list$alpha[i,,],
      w = sample_list$w[i,],
      model_data = model_data,
      lambda = sample_list$lambda[i,,],
      fixed_sd = fixed_sd
    )
  }

  if(verbose) {
    cat("\n")
  }

  sample_list = filter_chain(
    sample_list,
    burn_in = burn_in,
    iters = iters,
    thin = thin
  )

  out = list(
    w_class = sample_list$w |> comp_class(),
    sample_list = sample_list,
    model_data = model_data,
    fixed_sd = fixed_sd,
    lambda = lambda,
    args = args
  )

  class(out) = "seqclust"
  return(out)

}
